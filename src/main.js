import chalk from "chalk";
// import execa from "execa";
import fs from "fs";
import Listr from "listr";
// import ncp from "ncp";
import path from "path";
// import { projectInstall } from "pkg-install";
import license from "spdx-license-list/licenses/MIT";
import { promisify } from "util";

// const access = promisify(fs.access);
const writeFile = promisify(fs.writeFile);
// const copy = promisify(ncp);

// const copyTemplateFiles = async (options) => {
//   return copy(options.templateDirectory, options.targetDirectory, {
//     clobber: false,
//   });
// };

// const initGit= async(options)=> {
//   const result = await execa("git", ["init"], {
//     cwd: options.targetDirectory,
//   });
//   if (result.failed) {
//     return Promise.reject(new Error("Failed to initialize git"));
//   }
//   return;
// }

const createFolder = (options) => {
  if (fs.existsSync(`${process.cwd()}/${options.nameProject}`)) {
    process.chdir(`${process.cwd()}/${options.nameProject}`);
  } else {
    fs.mkdirSync(options.nameProject);
    process.chdir(`${process.cwd()}/${options.nameProject}`);
  }
  return;
};
const createPackage = (options) => {
  let devDependencies = [
    {
      gulp: "^4.0.2",
      "browser-sync": "^2.27.5",
      del: "^6.0.0",
      "gulp-if": "^3.0.0",
      "gulp-notify": "^4.0.0",
      "gulp-image": "^6.2.1",
      "gulp-concat": "^2.6.1",
      "node-w3c-validator": "^2.0.1",
      "gulp-sourcemaps": "^3.0.0",
      "gulp-rev": "^9.0.0",
      "gulp-rev-rewrite": "^5.0.0",
      "gulp-rev-delete-original": "^0.2.3",
      "gulp-autoprefixer": "^8.0.0",
      "gulp-babel": "^8.0.0",
      "gulp-svg-sprite": "^1.5.0",
      "gulp-clean-css": "^4.3.0",
      "gulp-uglify-es": "^3.0.0",
      "gulp-htmlmin": "^5.0.1",
    },
  ];
  switch (options.html) {
    case "HTML5":
      devDependencies.push({
        "gulp-file-include": "^2.3.0",
      });
      break;
    case "Pug":
      break;
  }
  switch (options.css) {
    case "SASS":
      devDependencies.push({
        "gulp-sass": "^5.0.0",
      });
      break;
    case "LESS":
      devDependencies.push({
        "gulp-less": "^5.0.0",
      });
      break;
    case "Stylus":
      devDependencies.push({
        "gulp-stylus": "^2.7.0",
      });
      break;
    case "CSS3":
      break;
  }
  switch (options.js) {
    case "JavaScript":
      break;
    case "TypeScript":
      break;
  }
  let dependencies = Object.assign({}, ...devDependencies);
  let packageTemplate = {
    name: "create-gulp-template",
    description: "",
    version: "1.0.0",
    main: "gulpfile.js",
    scripts: {
      html: "node-w3c-validator -f lint -evH -i public/**/*.html",
      dev: "gulp",
      build: "gulp build",
      cache: "gulp cache",
    },
    author: "Urij Horuzij",
    license: "MIT",
    devDependencies: dependencies,
  };
  return writeFile(
    `${process.cwd()}/package.json`,
    JSON.stringify(packageTemplate, null, 4),
    "utf8"
  );
};
const createGitignore = async () => {
  const gitignoreTemplate = `# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*`;
  return writeFile(`${process.cwd()}/.gitignore`, gitignoreTemplate, "utf8");
};
const createLicense = async (options) => {
  const licenseContent = license.licenseText
    .replace("<year>", new Date().getFullYear())
    .replace("<copyright holders>", `${options.name}`);
  return writeFile(`${process.cwd()}/LICENSE`, licenseContent, "utf8");
};
const createFolders = async (options) => {
  fs.mkdirSync("img");
  fs.mkdirSync("img/svg");
  fs.mkdirSync("partials");
  fs.mkdirSync("resources");
  fs.mkdirSync("resources/fonts");
  switch (options.css) {
    case "SASS":
      fs.mkdirSync("scss");
      fs.mkdirSync("scss/components");
      fs.mkdirSync("scss/mixins");
      fs.mkdirSync("scss/vendor");
      break;
    case "LESS":
      fs.mkdirSync("less");
      fs.mkdirSync("less/components");
      fs.mkdirSync("less/mixins");
      fs.mkdirSync("less/vendor");
      break;
    case "Stylus":
      fs.mkdirSync("stylus");
      fs.mkdirSync("stylus/components");
      fs.mkdirSync("stylus/mixins");
      fs.mkdirSync("stylus/vendor");
      break;
    case "CSS3":
      fs.mkdirSync("css");
      fs.mkdirSync("css/components");
      fs.mkdirSync("css/vendor");
      break;
  }
  switch (options.js) {
    case "JavaScript":
      fs.mkdirSync("js");
      fs.mkdirSync("js/components");
      fs.mkdirSync("js/vendor");
      break;
    case "TypeScript":
      fs.mkdirSync("ts");
      fs.mkdirSync("ts/components");
      fs.mkdirSync("ts/vendor");
      break;
  }
};
const createHTML = async (options) => {
  const htmlTemplate = `<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="img/favicon.ico" type="image/x-icon">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="theme-color" content="#111111">
    <title>Document</title>
    <link rel="stylesheet" href="css/global.css">
    <link rel="stylesheet" href="css/vendor.css">
    <link rel="stylesheet" href="css/main.css">
</head>
<body>
    <!-- @include('html/h1.html') пример инклуда -->
    <script src="js/vendor.js"></script>
    <script src="js/main.js"></script>
</body>
</html>`;
  switch (options.html) {
    case "HTML5":
      return writeFile(`${process.cwd()}/index.html`, htmlTemplate, "utf8");
    case "Pug":
      return;
  }
};
const createJS = async (options) => {
  switch (options.js) {
    case "JavaScript":
      writeFile(
        `${process.cwd()}/js/global.js`,
        `console.log("global");`,
        "utf8"
      );
      writeFile(
        `${process.cwd()}/js/main.js`,
        `/**
        * название функции
        *
        * @param {number} first - первое число
        * @returns {number}
        */`,
        "utf8"
      );
      break;
    case "TypeScript":
      break;
  }
};
const createCSS = async (options) => {
  switch (options.css) {
    case "SASS":
      writeFile(
        `${process.cwd()}/scss/vendor/normalize.css`,
        fs.readFileSync(__dirname + "/normalize.css", (err, data) => {
          if (err) console.log(err);
          return data;
        }),
        "utf8"
      );
      writeFile(
        `${process.cwd()}/scss/mixins/_font-face.scss`,
        `@mixin font-face($font-family, $url, $weight, $style) {
  @font-face {
    font-family: "#{$font-family}";
    src: url("../fonts/#{$url}.woff2") format("woff2");
    font-weight: #{$weight};
    font-display: swap;
    font-style: $style;
  }
}`,
        "utf8"
      );
      writeFile(
        `${process.cwd()}/scss/_fonts.scss`,
        `// @include font-face("Muller", "../fonts/MullerRegular", 400, normal);`,
        "utf8"
      );
      writeFile(
        `${process.cwd()}/scss/_mixins.scss`,
        `@import "./mixins/font-face";`,
        "utf8"
      );
      writeFile(
        `${process.cwd()}/scss/_vars.scss`,
        `:root {
  --color-black: #000;
  --color-white: #fff;
}`,
        "utf8"
      );
      writeFile(
        `${process.cwd()}/scss/global.scss`,
        `@import "vars";
@import "mixins";
@import "fonts";`,
        "utf8"
      );
      writeFile(
        `${process.cwd()}/scss/main.scss`,
        ` @import 'vars';
// @import "./components/header";`,
        "utf8"
      );
      writeFile(
        `${process.cwd()}/scss/vendors.scss`,
        `@import "./vendor/normalize";`,
        "utf8"
      );
      break;
    case "LESS":
      writeFile(
        `${process.cwd()}/less/vendor/normalize.css`,
        fs.readFileSync(__dirname + "/normalize.css", (err, data) => {
          if (err) console.log(err);
          return data;
        }),
        "utf8"
      );
      writeFile(
        `${process.cwd()}/less/mixins/font-face.less`,
        `.font-face(@font-family, @url, @weight, @style) {
  @font-face {
    font-family: @font-family;
    src: url("../fonts/{@url}.woff2") format("woff2");
    font-weight: @weight;
    font-display: swap;
    font-style: $style;
  }
}`,
        "utf8"
      );
      writeFile(
        `${process.cwd()}/less/fonts.less`,
        `// @include font-face("Muller", "../fonts/MullerRegular", 400, normal);`,
        "utf8"
      );
      writeFile(
        `${process.cwd()}/less/mixins.less`,
        `@import "./mixins/font-face";`,
        "utf8"
      );
      writeFile(
        `${process.cwd()}/less/vars.less`,
        `:root {
  --color-black: #000;
  --color-white: #fff;
}`,
        "utf8"
      );
      writeFile(
        `${process.cwd()}/less/global.less`,
        `@import "vars";
@import "mixins";
@import "fonts";`,
        "utf8"
      );
      writeFile(
        `${process.cwd()}/less/main.less`,
        ` @import 'vars';
// @import "./components/header";`,
        "utf8"
      );
      writeFile(
        `${process.cwd()}/less/vendors.less`,
        `@import "./vendor/normalize";`,
        "utf8"
      );
      break;
    case "Stylus":
      writeFile(
        `${process.cwd()}/stylus/vendor/normalize.css`,
        fs.readFileSync(__dirname + "/normalize.css", (err, data) => {
          if (err) console.log(err);
          return data;
        }),
        "utf8"
      );
      writeFile(
        `${process.cwd()}/stylus/mixins/font-face.styl`,
        `@mixin font-face($font-family, $url, $weight, $style) {
        @font-face {
          font-family: "#{$font-family}";
          src: url("../fonts/#{$url}.woff2") format("woff2");
          font-weight: #{$weight};
          font-display: swap;
          font-style: $style;
        }
      }
      `,
        "utf8"
      );
      writeFile(
        `${process.cwd()}/stylus/fonts.styl`,
        `// @include font-face("Muller", "../fonts/MullerRegular", 400, normal);`,
        "utf8"
      );
      writeFile(
        `${process.cwd()}/stylus/mixins.styl`,
        `@import "./mixins/font-face";`,
        "utf8"
      );
      writeFile(
        `${process.cwd()}/stylus/vars.styl`,
        `:root {
        --color-black: #000;
        --color-white: #fff;
      }`,
        "utf8"
      );
      writeFile(
        `${process.cwd()}/stylus/global.styl`,
        `@import "vars";
      @import "mixins";
      @import "fonts";`,
        "utf8"
      );
      writeFile(
        `${process.cwd()}/stylus/main.styl`,
        ` @import 'vars';
      // @import "./components/header";`,
        "utf8"
      );
      writeFile(
        `${process.cwd()}/stylus/vendors.styl`,
        `@import "./vendor/normalize";`,
        "utf8"
      );
      break;
    case "CSS3":
      writeFile(
        `${process.cwd()}/css/vendor/normalize.css`,
        fs.readFileSync(__dirname + "/normalize.css", (err, data) => {
          if (err) console.log(err);
          return data;
        }),
        "utf8"
      );
      writeFile(
        `${process.cwd()}/css/fonts.css`,
        `/* @font-face {
          font-family: "#{$font-family}";
          src: url("../fonts/#{$url}.woff2") format("woff2");
          font-weight: #{$weight};
          font-display: swap;
          font-style: $style;
        } */`,
        "utf8"
      );
      writeFile(
        `${process.cwd()}/css/global.css`,
        `/* @import "vars";
        @import "fonts"; */`,
        "utf8"
      );
      writeFile(
        `${process.cwd()}/css/main.css`,
        `@import 'vars';
        /* @import "./components/header"; */`,
        "utf8"
      );
      writeFile(
        `${process.cwd()}/css/vars.css`,
        `:root {
          --color-black: #000;
          --color-white: #fff;
        }`,
        "utf8"
      );
      writeFile(
        `${process.cwd()}/css/vendor.css`,
        `@import "./vendor/normalize";`,
        "utf8"
      );
      break;
  }
};
const createGulpFile = async (options) => {
  let gulpfileTemplate = `
  const { src, dest, series, watch } = require("gulp");
const autoprefixer = require("gulp-autoprefixer");
const babel = require("gulp-babel");
const cleanCSS = require("gulp-clean-css");
const uglify = require("gulp-uglify-es").default;
const del = require("del");
const browserSync = require("browser-sync").create();
const svgSprite = require("gulp-svg-sprite");

const sourcemaps = require("gulp-sourcemaps");
const rev = require("gulp-rev");
const revRewrite = require("gulp-rev-rewrite");
const revDel = require("gulp-rev-delete-original");
const gulpif = require("gulp-if");
const notify = require("gulp-notify");
const image = require("gulp-image");
const { readFileSync } = require("fs");
const concat = require("gulp-concat");
const htmlmin = require("gulp-htmlmin");
${
  options.html == "HTML5"
    ? `const fileInclude = require("gulp-file-include");`
    : null
}
${options.css == "Stylus" ? `const stylus = require("gulp-stylus");` : null}

let isProd = false;

const toProd = (done) => {
  isProd = true;
  done();
};
const clean = () => {
  return del(["public/*"]);
};
const cache = () => {
  return src("public/**/*.{css,js,svg,png,jpg,jpeg,woff2}", {
    base: "public",
  })
    .pipe(rev())
    .pipe(revDel())
    .pipe(dest("public"))
    .pipe(rev.manifest("rev.json"))
    .pipe(dest("public"));
}
const rewrite = () => {
  const manifest = readFileSync("public/rev.json");
  src("public/css/*.css")
    .pipe(
      revRewrite({
        manifest,
      })
    )
    .pipe(dest("public/css"));
  return src("public/**/*.html")
    .pipe(
      revRewrite({
        manifest,
      })
    )
    .pipe(dest("public"));
};
const htmlMinify = () => {
  return src("public/**/*.html")
    .pipe(
      htmlmin({
        collapseWhitespace: true,
      })
    )
    .pipe(dest("public"));
};
const resources = () => {
  return src("./src/resources/**").pipe(dest("./public"));
};
const images = () => {
  return src([
    "./src/img/**.jpg",
    "./src/img/**.png",
    "./src/img/**.jpeg",
    "./src/img/*.svg",
    "./src/img/**/*.jpg",
    "./src/img/**/*.png",
    "./src/img/**/*.jpeg",
  ])
    .pipe(gulpif(isProd, image()))
    .pipe(dest("./public/img"));
};
const svgSprites = () => {
  return src("./src/img/svg/**.svg")
    .pipe(
      svgSprite({
        mode: {
          stack: {
            sprite: "../sprite.svg",
          },
        },
      })
    )
    .pipe(dest("./public/img"));
};
  const htmlInclude = () => {
  return src(["./src/*.html"])
    .pipe(
      fileInclude({
        prefix: "@",
        basepath: "@file",
      })
    )
    .pipe(dest("./public"))
    .pipe(browserSync.stream());
};
const styles = () => {
  return src("./src/stylus/**/*.styl")
    .pipe(gulpif(!isProd, sourcemaps.init()))
    .pipe(stylus().on("error", notify.onError()))
    .pipe(
      autoprefixer({
        cascade: false,
      })
    )
    .pipe(gulpif(isProd, cleanCSS({ level: 2 })))
    .pipe(gulpif(!isProd, sourcemaps.write(".")))
    .pipe(dest("./public/css/"))
    .pipe(browserSync.stream());
};

const scripts = () => {
  src("./src/js/vendor/**.js")
    .pipe(concat("vendor.js"))
    .pipe(gulpif(isProd, uglify().on("error", notify.onError())))
    .pipe(dest("./public/js/"));
  return src([
    "./src/js/global.js",
    "./src/js/components/**.js",
    "./src/js/main.js",
  ])
    .pipe(gulpif(!isProd, sourcemaps.init()))
    .pipe(
      babel({
        presets: ["@babel/env"],
      })
    )
    .pipe(concat("main.js"))
    .pipe(gulpif(isProd, uglify().on("error", notify.onError())))
    .pipe(gulpif(!isProd, sourcemaps.write(".")))
    .pipe(dest("./public/js"))
    .pipe(browserSync.stream());
};

const watchFiles = () => {
  browserSync.init({
    server: {
      baseDir: "./public",
    },
  });

  watch("./src/resources/**", resources);
  watch("./src/img/*.{jpg,jpeg,png,svg}", images);
  watch("./src/img/**/*.{jpg,jpeg,png}", images);
  watch("./src/img/svg/**.svg", svgSprites);
  watch("./src/stylus/**/*.styl", styles);
  watch("./src/js/**/*.js", scripts);
  watch("./src/partials/*.html", htmlInclude);
  watch("./src/*.html", htmlInclude);
};

exports.default = series(
  clean,
  htmlInclude,
  scripts,
  styles,
  resources,
  images,
  svgSprites,
  watchFiles
);

exports.build = series(
  toProd,
  clean,
  htmlInclude,
  scripts,
  styles,
  resources,
  images,
  svgSprites,
  htmlMinify
);

exports.cache = series(cache, rewrite);
  `;
  writeFile(`${process.cwd()}/gulpfile.js`, gulpfileTemplate, "utf8");
};
export const createProject = async (options) => {
  options = {
    ...options,
    targetDirectory: process.cwd(),
    name: "Urij Horuzij",
  };

  const tasks = new Listr(
    [
      {
        title: "Create folder",
        task: () => createFolder(options),
      },
      {
        title: "Create project files",
        task: () => {
          createPackage(options);
          createGitignore();
          createLicense(options);
          createFolders(options);
          createHTML(options);
          createJS(options);
          createCSS(options);
          createGulpFile(options);
        },
      },
      // {
      //   title: "Copy project files",
      //   task: () => copyTemplateFiles(options),
      // },
      // {
      //   title: "Initialize git",
      //   task: () => initGit(options),
      //   enabled: () => options.git,
      // },
      // {
      //   title: "Install dependencies",
      //   task: () =>
      //     projectInstall({
      //       cwd: options.targetDirectory,
      //     }),
      // },
    ],
    {
      exitOnError: false,
    }
  );

  await tasks.run();
  console.log(chalk.green.bold("DONE"));
  return true;
};
